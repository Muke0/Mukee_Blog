# GC垃圾回收
## 什么是GC
GC指的是Garbage Collect。其中垃圾指的是没有任何引用指向的一个对象或者多个对象（循环引用），它们仍然占用内存空间。GC是一种自动的存储管理机制。
## Java和C++垃圾回收的区别
|  语言    | 优点   | 缺点 |
|  ----  | ----   | ---- |
| Java | GC自动处理垃圾，开发效率高 | 运行效率低 | 
| C++  | 运行效率高 | 开发效率低，须手动回收垃圾 | 
## GC如何找到垃圾
|  方法  | 思想    | 优点   | 缺点 |
|  ----  | ----   | ----   | ---- |
| 引用计数法 | 给对象添加一个引用计数器，每当一个地方引用这个对象的时候，计数器值就+1；当引用失效时，计数器值-1 | 运行效率低 | 不能解决对象之间相互引用的情况，开销比较大，频繁且大量的引用变化，带来大量的额外运算 |
| 可达性分析  | 通过一系列称为 "GC Roots" 的对象作为起始点，从这些节点向下搜索，当GC Roots到某个对象不可达时，这个对象就是可回收的 | 更加精确和严谨，可以分析出循环数据结构相互引用的情况 | 实现比较复杂，需要分析大量的数据，消耗大量时间|
## GC如何清理垃圾
|  方法  | 思想    | 优点   | 缺点 |
|  ----  | ----   | ----   | ---- |
| 标记清除 | 对于标记的垃圾，直接在原地清除 | 算法简单 | 容易产生内存垃圾，效率不高 |
| 标记压缩  | 将有用的对象放到头部，剩下的空间全部清空 | 不会产碎片片，不会内存减半 | 效率不高|
| 拷贝  | 只使用一半的内存，当GC时，将有用的对象复制到另一半内存，再清空当前这一半内存 | 效率高 | 浪费内存空间 |
## 堆内存逻辑分区
对于Hot Spot虚拟机来说，内存分为新生代和老年代。新生代和老年代比例默认为1：2。新生代又分为eden区，from区和to区，空间默认占比为8：1：1。
## GC分类
### Minor GC
指发生在新生代的垃圾收集动作，Java对象大多存活时间不长，所以Minor GC的发生会比较频繁，回收速度也比较快
在新生代的Eedn区满了会触发Minor GC
### Full GC
System.gc()方法的调用，此方法会建议JVM进行Full GC，但JVM可能不接受这个建议，所以不一定会执行。 
老年代空间不足，创建的大对象的内存大于老年代空间，导致老年代空间不足，则会发生Full GC 
JDK1.7及以前的永久代空间满了，在JDK1.7以前，HotSpot虚拟机的方法区是永久代实现都得，在永久代中会存放一些Class的信息、常量、静态变量等数据，在永久代满了，并且没有配置CMS GC的情况下就会触发Full GC，在JDK1.8开始移除永久代也是为了减少Full GC的频率。  
空间分配担保失败，通过Minor GC后进入老年代的平均大小大于老年代的可用空间，会触发Full GC。  
Full GC发生过于频繁，会影响性能
