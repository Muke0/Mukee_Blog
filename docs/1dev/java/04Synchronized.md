# Synchronized
## 锁升级
无锁->偏向锁->轻量级锁->重量级锁，锁的升级只能单向，锁不会降级。
|  锁    | 优点   | 缺点 |适用场景|
|  ----  | ----   | ---- | ---- |
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |
| 轻量级锁  | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应速度，同步块执行速度非常快 |
| 重量级锁  | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较慢 |
![锁的四种状态及切换](/1dev/java/Synchronized/fourStates.png "锁的四种状态及切换")
## 问题
### 什么是偏向锁、轻量级锁、重量级锁
### Synchronized提供了锁的公平性吗？
是不公平的。Lock可以实现锁的公平性，默认不公平。
### 如何在保证线程安全性的前提下，减少加锁带来的性能损耗
#### 使用层面的优化
控制加锁的粒度，也就是锁的范围。Synchronized包含的代码块越小，粒度越小，性能损耗越小。
#### JVM层面的优化
1. 编译器的优化，深度编译（锁的膨胀和锁的消除）
2. 锁的升级